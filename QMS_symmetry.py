import numpy as np
from scipy import linalg as ln
import random as r



#function bank


def construct_X(n):
    """
    Builds a matrix that represents the action of sum X_i on the Lamb Dicke basis
    n: integer, number of qubits
    """
    mat = np.zeros((n+1,n+1))
    for i in range(0,n):
        mat[i][i+1] = np.sqrt((n-i)*(i+1))

    mat = mat + mat.transpose()

    return mat

def construct_Z(n):
    """
    Builds a matrix that represents the action of sum Z_i on the Lamb Dicke basis
    n: integer, number of qubits
    """
    mat = np.zeros((n+1,n+1))
    for i in range(0,n):
        mat[i][i] = n-(2*i)
    return mat
        
def U_sum_X(n,theta):
    """
    Builds a matrix that represents the action of the unitary generated by sum X_i on the Lamb Dicke basis
    n: integer, number of qubits
    theta: float, rotation angle
    """
    U =ln.expm(-(1j)*(theta/2)*construct_X(n))
    return U

def U_sum_Z(n,theta):
    """
    Builds a matrix that represents the action of the unitary generated by sum Z_i on the Lamb Dicke basis
    n: integer, number of qubits
    theta: float, rotation angle
    """
    U =ln.expm(-(1j)*(theta/2)*construct_Z(n))
    return U    


def Hamming_Spike_H(n,):
    """
    Builds a matrix that represents the permutation symmetric Hamiltonian with a spike at n/4 in the Lamb-Dicke basis
    n: integer, number of qubits
    """
    mat = np.zeros((n+1,n+1))
    for i in range(n+1):
        if i == np.floor(n/4):
            mat[i][i] = n**4
        else:
            mat[i][i] = i
    return mat

def Hamming_Spike_Width(n,w = 3):
    """
    Builds a matrix that represents the permutation symmetric Hamiltonian with a spike at n/4 +- w in the Lamb-Dicke basis
    n: integer, number of qubits
    w: integer, width of the spike
    """
    mat = np.zeros((n+1,n+1))
    for i in range(n+1):
        if i < (np.floor(n/4)+w) and i > (np.floor(n/4)-w):
            mat[i][i] = n**4
        else:
            mat[i][i] = i
    return mat



# ###Dpont have the implementation for these down yet
# def Entropy_Approx(n,i):
#     """"
#     Returns an approximation of log(n choose i) (basically the shannon entropy)
#     n: integer
#     i: integer in the interval [0,n]
#     """
#     if i == 0 or i==n:
#         return 0
#     else:
#         return i*np.log(n/i) + (n-i)*np.log(n/(n-i))


# def Hamming_Spike_Width_Entropy(n,beta,w = 3):
#     """
#     Builds a matrix that represents the permutation symmetric Hamiltonian with a spike at n/4 +- w in the Lamb-Dicke basis
#     with an added entropic factor which is an approximation of log(n choose i)
#     n: integer, number of qubits
#     beta: float, should match inverse temperature of the simulation
#     w: integer, width of the spike

#     """
#     mat = np.zeros((n+1,n+1))
#     for i in range(n+1):
#         if i < (np.floor(n/4)+w) and i > (np.floor(n/4)-w):
#             mat[i][i] = n**4 - (1/beta)*Entropy_Approx(n,i)
#         else:
#             mat[i][i] = i - (1/beta)*Entropy_Approx(n,i)
#     return mat

def Tranverse_Hamming_H(H,n,gamma):
    """
    Builds a matrix that represents the permutation symmetric Hamiltonian H with a transverse field of strength gamma in the Lamb-Dicke basis
    H: (n+1)x(n+1) ndarray, a permutation symmetric Hamiltonian represented in the Lamb Dicke basis
    n: integer, number of qubits
    gamma: float, strength of the transverse field
    """

    return H(n) + gamma*construct_X(n)




def Build_P(w,v,Us,beta):
    """
    Build an (n+1)x(n+1) stochastic matrix P whose [i][j]'th entry encodes the probability to transition from
    the ith eigenstate to the jth eigenstate under one step of the QMS walk generated by the ensemble of unitaries 
    Us, with each element of Us picked with uniform probability. 
    w: ndarray, list of eigenvalues returned from ln.eig
    v: ndarray, list of eigenvectors returned from ln.eig
    Us: list of (n+1)x(n+1) ndarrays, each ndarray is a representation of a permutationally symmetric unitary in the Lamb Dicke basis
    beta: float, inverse temperature
    """
    s = np.argsort(w)
    n = len(w)

    #probability to pick each U in an ensemble
    p = 1/len(Us)

    P = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            element = 0
            for uni in Us:

                #calculate matrix elements of unitary
                val = (np.conj(v[:,s[j]])@(uni@v[:,s[i]]))

                #Mod square the matrix elements
                vsv = val*np.conj(val)

                #add in modsquare matrix element multiplied by probability of picking unitary in ensemble
                element += p*vsv

            element *= np.minimum(1,np.exp(-beta*(w[s[j]]-w[s[i]])))
            P[i][j] = element

    #renormalize rows
    for i in range(n):
        row_sum = sum([P[i][j] for j in range(n)])
        P[i][i] += 1-row_sum
    
    
    return P










def Solve_Eigensystems(H,n,gamma_max,gamma_min,copies):
    """
    Solve all of the eigensystems for different gammas of the transverse field version of H
    H: (n+1)x(n+1) ndarray, a permutation symmetric Hamiltonian represented in the Lamb Dicke basis.
    n: integer, number of qubits
    gamma_max: float, maximum gamma of the ensemble
    gamma_min: float, minimum gamma of the ensemble
    copies: integer, number of elements in the ensemble
    """
    eigensystem_list = [ln.eig(Tranverse_Hamming_H(H,n,gamma)) for gamma in np.linspace(gamma_max,gamma_min,copies)]
    return eigensystem_list

def build_Ensemble_Of_Ps(e_list,Us,beta_max,beta_min,copies):
    """
    Builds a list of (n+1)x(n+1) ndarrays  of length copies, each encoding the transition probabilities of one step of the QMS walk
    for gammas and betas in the intervals [gamma_max,gamma_min] and [beta_min,beta_max].
    e_list: list of eigensystems returned from ln.eig
    Us: list of (n+1)x(n+1) ndarrays, each ndarray is a representation of a permutationally symmetric unitary in the Lamb Dicke basis
    beta_max: float, maximum beta of the ensemble
    beta_min: float, minimum beta of the ensemble
    copies: integer, number of elements in the ensemble
    """

    #Generate 1D ndarrays of length copies corresponding to equally spaced gammas and betas in the intervals:
    #[gamma_max,gamma_min] and [beta_min, beta_max]. Note that the order of the min and max are different because
    # large gamma and small beta both correspond to states that are near the uniform distribuiton when sampled in the
    #computational basis
    betas = np.linspace(beta_min,beta_max,copies)

    Ps = []
    #iterate through and and build each P for each different gamma and beta
    for i in range(copies):
        #Start with big gamma small beta
        beta = betas[i]
        w,v = e_list[i]
        P = Build_P(w,v,Us,beta)
        Ps.append(P)

    return Ps


def buildSwapPs(e_list,beta_max,beta_min,copies):
    """
    Builds a length copies-1 list of (n+1)x(n+1)x(n+1)x(n+1) ndarrays that encode the transition probabilities between
    eigenstates in the ith and (i+1)th subyestem for i in range(copies-1) after the application of the swap 
    operator and the modified QMET step. the P[i][j][k][l] element of each P is the probability to transition
    from the eigen state i in the first system and eigen state j in the second system, to eigenstate k in the first 
    system and eigenstate l in the second system.
    e_list: list of eigensystems returned by ln.eig
    beta_max: float, maximum beta of the ensemble
    beta_min: float, minimum beta of the ensemble
    copies: integer, number of elements in the ensemble
    """
    
    #argsort each eigensystem by eigenvalue from smallest to largest
    sort_list =[np.argsort(i[0]) for i in e_list]

    #list of betas in the ensemble
    beta_list = np.linspace(beta_min,beta_max,copies)

    SwapPs = []
    #iterate throug each pair (i,i+1) = c
    for c in range(copies-1):
        P = np.zeros((n+1,n+1,n+1,n+1))
        # iterate through initial eigenstates i and j
        for i in range(n+1):
            for j in range(n+1):
                #iterate through post transition eigenstates k and l
                for k in range(n+1):
                    for l in range(n+1):

                        #eigenstates
                        ui = e_list[c][1][:,sort_list[c][i]]
                        uj = e_list[c+1][1][:,sort_list[c+1][j]]
                        uk = e_list[c][1][:,sort_list[c][k]]
                        ul = e_list[c+1][1][:,sort_list[c+1][l]]

                        #eigen-energies
                        Ei = e_list[c][0][sort_list[c][i]]
                        Ej = e_list[c+1][0][sort_list[c+1][j]]
                        Ek = e_list[c][0][sort_list[c][k]]
                        El = e_list[c+1][0][sort_list[c+1][l]]

                        #Compute overlaps
                        vli = np.conj(ui)@ul
                        vkj = np.conj(uj)@uk

                        #convert to mod squared overlaps
                        vli *= np.conj(vli) 
                        vkj *= np.conj(vkj)

                        #compute metropolis factor
                        met_factor = np.min([1,np.exp(-beta_list[c]*Ek - beta_list[c+1]*El + beta_list[c]*Ei + beta_list[c+1]*Ej)])


                        P[i][j][k][l] += met_factor*vli*vkj 

        #normalize each row
        for i in range(n+1):
            for j in range(n+1):
                row_sum = sum([P[i][j][k][l] for k in range(n+1) for l in range(n+1)])    
                P[i][j][i][j] += 1-row_sum  

        SwapPs.append(P)
    
    return SwapPs






steps = 1000
n=25
beta_min = 0
beta_max = 1
gamma_max = 0
gamma_min = 0 
copies = 10
theta = .1
H = Hamming_Spike_Width
Us = [U_sum_X(n,theta),U_sum_X(n,-theta),U_sum_Z(n,theta),U_sum_Z(n,-theta)]



#Goal for simulating a parallel temepering instance of QMET:
#   - Build up a stochastic matrix for each Hamlitonain in the tempering ensemble separately, 
#     these will then be used as a look up table when applying the dynamics of each of the 
#     steps in the tempering procedure that correspond to a walk on just one of the 
#     Hamiltonians.
#   - For the SWAP step, if each individual H in the tempering ensemble is d dimensional, the 
#     SWAP only acts on a d^2 dimensional subsystem. Since the input state will alwyas be a product 
#     state over the different system registers, this means we can simulate each swap with a d^2 by d^2 
#     stochastic matrix. We create one of these for each neigboring copies of systems i, i+1

e_list = Solve_Eigensystems(H,n,gamma_max,gamma_min,copies)
Ps = build_Ensemble_Of_Ps(e_list,Us,beta_max,beta_min,copies)
SwapPs = buildSwapPs(e_list,beta_max,beta_min,copies)

state =  [r.randint(0,n) for i in range(copies)]

print(state)



for i in range(steps):
    #system updates
    for c in range(copies):
        current_state = state[c]
        roulette_wheel = [sum(Ps[c][current_state][:l+1]) for l in range(n+1)]
        monte_carlo = r.uniform(0,1)
        for index,spoke in enumerate(roulette_wheel):
            if monte_carlo < spoke:
                state[c] = index
                break
            
    
    #swaps
    for c in range(copies-1):
        current_state_1 = state[c]
        current_state_2 = state[c+1]

        
        #flatten row of P, the rows [k][l] entry is now indexed by [k(n+1) + l]
        row = []
        for k in range(n+1):
            for l in range(n+1):
                row.append(SwapPs[c][current_state_1][current_state_2][k][l])


        #build roulette wheel
        roulette_wheel = []
        for k in range(n+1):
            for l in range(n+1):
                roulette_wheel.append(sum(row[:k*(n+1)+l+1]))

        #determine state to transition to.        
        monte_carlo = r.uniform(0,1)
        brk = False
        for k in range(n+1):
            if brk:
                break
            for l in range(n+1):
                index = k*(n+1) + l
                if monte_carlo < roulette_wheel[index]:
                    state[c] = k
                    state[c+1] = l
                    brk = True
                    break

    print(state)




    
























