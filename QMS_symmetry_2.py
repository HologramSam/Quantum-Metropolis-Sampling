import numpy as np
from scipy import linalg as ln
import random as r


#This file will implement the walk in a more traditional manner


#function bank

def construct_X(n):
    """
    Builds a matrix that represents the action of sum X_i on the Lamb Dicke basis
    n: integer, number of qubits
    """
    mat = np.zeros((n+1,n+1))
    for i in range(0,n):
        mat[i][i+1] = np.sqrt((n-i)*(i+1))

    mat = mat + mat.transpose()

    return mat

def construct_Z(n):
    """
    Builds a matrix that represents the action of sum Z_i on the Lamb Dicke basis
    n: integer, number of qubits
    """
    mat = np.zeros((n+1,n+1))
    for i in range(0,n):
        mat[i][i] = n-(2*i)
    return mat
        
def U_sum_X(n,theta):
    """
    Builds a matrix that represents the action of the unitary generated by sum X_i on the Lamb Dicke basis
    n: integer, number of qubits
    theta: float, rotation angle
    """
    U =ln.expm(-(1j)*(theta/2)*construct_X(n))
    return U

def U_sum_Z(n,theta):
    """
    Builds a matrix that represents the action of the unitary generated by sum Z_i on the Lamb Dicke basis
    n: integer, number of qubits
    theta: float, rotation angle
    """
    U =ln.expm(-(1j)*(theta/2)*construct_Z(n))
    return U    


def Hamming_Spike_H(n):
    """
    Builds a matrix that represents the permutation symmetric Hamiltonian with a spike at n/4 in the Lamb-Dicke basis
    n: integer, number of qubits
    """
    mat = np.zeros((n+1,n+1))
    for i in range(n+1):
        if i == np.floor(n/4):
            mat[i][i] = n**4
        else:
            mat[i][i] = i
    return mat

def Hamming_Spike_Width(n,w = 3):
    """
    Builds a matrix that represents the permutation symmetric Hamiltonian with a spike at n/4 +- w in the Lamb-Dicke basis
    n: integer, number of qubits
    w: integer, width of the spike
    """
    mat = np.zeros((n+1,n+1))
    for i in range(n+1):
        if i < (np.floor(n/4)+w) and i > (np.floor(n/4)-w):
            mat[i][i] = n**4
        else:
            mat[i][i] = i
    return mat

def Entropy_Approx(n,i):
    """"
    Returns an approximation of log(n choose i) (basically the shannon entropy)
    n: integer
    i: integer in the interval [0,n]
    """
    if i == 0 or i==n:
        return 0
    else:
        return i*np.log(n/i) + (n-i)*np.log(n/(n-i))


def Hamming_Spike_Width_Entropy(n,w = 3):
    """
    Builds a matrix that represents the permutation symmetric Hamiltonian with a spike at n/4 +- w in the Lamb-Dicke basis
    with an added entropic factor which is an approximation of log(n choose i)
    n: integer, number of qubits
    w: integer, width of the spike
    """
    mat = np.zeros((n+1,n+1))
    for i in range(n+1):
        if i < (np.floor(n/4)+w) and i > (np.floor(n/4)-w):
            mat[i][i] = n**4 - Entropy_Approx(n,i)
        else:
            mat[i][i] = i - Entropy_Approx(n,i)
    return mat



def Tranverse_Hamming_H(H,n,gamma):
    """
    Builds a matrix that represents the permutation symmetric Hamiltonian H with a transverse field of strength gamma in the Lamb-Dicke basis
    H: (n+1)x(n+1) ndarray, a permutation symmetric Hamiltonian represented in the Lamb Dicke basis
    n: integer, number of qubits
    gamma: float, strength of the transverse field
    """

    return H(n) + gamma*construct_X(n)

       

        
#Main program
        

H = Hamming_Spike_Width
steps = 1000
n=16
beta_min = 0
beta_max = 1
gamma_max = 0
gamma_min = 0 
copies = 10
theta = .1
Us = [U_sum_X(n,theta),U_sum_X(n,-theta),U_sum_Z(n,theta),U_sum_Z(n,-theta)]
p = 1/len(Us)
roulette_U = [(i+1)*p for i in range(len(Us))]


#calculate a list of all eigensystems for the different H's, as well as an argsort list forthe eigenvalues
eigensystem_list = [ln.eig(Tranverse_Hamming_H(H,n,gamma)) for gamma in np.linspace(gamma_max,gamma_min,copies)]
s = [np.argsort(i[0]) for i in eigensystem_list]

#
beta_list = np.linspace(beta_min,beta_max,copies)

state =  [r.randint(8,n) for i in range(copies)]


###This part of the code is for computing average overlaps with computational basis states
gmax = 0
gmin = 0

c_ground = np.array([1 if i==0 else 0 for i in range(n+1)])

overlap0 = eigensystem_list[0][1][:,s[0][state[0]]]@c_ground
overlap0 *= np.conj(overlap0)

overlapl = eigensystem_list[copies-1][1][:,s[copies-1][state[copies-1]]]@c_ground
overlapl *= np.conj(overlapl)

gmax+=overlap0
gmin+=overlapl



print(state)

for step in range(steps):
    #local updates
    for copy in range(copies):

        #current state of copy
        c_state = state[copy]

        #eigenstate corresponding to current state
        e_state = eigensystem_list[copy][1][:,s[copy][c_state]]

        #energy corresponding to current state
        e_energy = eigensystem_list[copy][0][s[copy][c_state]]

        #pick unitary to apply
        monte_carlo_U = r.uniform(0,1)
        for index,spoke in enumerate(roulette_U):
            if monte_carlo_U < spoke:
                U = Us[index]
                break


        ###calculate proposal distribution probabilites and construct roulette wheel

        #first calculate complex amplitudes
        transition_probabilities = [U@e_state@eigensystem_list[copy][1][:,s[copy][i]] for i in range(n+1)]
        
        #mod square the amplitudes
        for i in range(len(transition_probabilities)):
            transition_probabilities[i] = np.conj(transition_probabilities[i])*transition_probabilities[i]

        #build roulette wheel
        roulette_wheel = [sum(transition_probabilities[:(k+1)]) for k in range(n+1)] 

        #determine proposal state
        monte_carlo = r.uniform(0,1)
        for index,spoke in enumerate(roulette_wheel):
            if monte_carlo < spoke:
                proposal = index
                break

        #calculate metropolis weight
        beta_c = beta_list[copy]    
        E_i = e_energy
        E_f = eigensystem_list[copy][0][s[copy][proposal]]
        met_weight = np.exp(-beta_c*(E_f-E_i))

        #accept/reject step
        monte_carlo = r.uniform(0,1)
        if monte_carlo < met_weight:
            state[copy] = proposal

    ##swap updates
    #iterate through pairs  (i, i+1) = copy 
    for copy in range(copies-1):

        #current states of system pair
        c_statei = state[copy]
        c_stateiplus1 = state[copy+1] 

        #eigenstates of current states
        e_statei = eigensystem_list[copy][1][:,s[copy][c_statei]]
        e_stateiplus1 = eigensystem_list[copy+1][1][:,s[copy+1][c_stateiplus1]]

        #energies of current states
        e_energyi = eigensystem_list[copy][0][s[copy][c_statei]]
        e_energyiplus1 = eigensystem_list[copy+1][0][s[copy+1][c_stateiplus1]]


        ###calculate transition probabilities and roulette wheel
        #start with complex amplitudes
        transition_probabilities = [e_stateiplus1@eigensystem_list[copy][1][:,s[copy][k]]*e_statei@eigensystem_list[copy+1][1][:,s[copy+1][l]] for k in range(n+1) for l in range(n+1)]

        #mod square to probabilities
        for i in range(len(transition_probabilities)):
            transition_probabilities[i] = np.conj(transition_probabilities[i])*transition_probabilities[i]

        #build roulette wheel
        roulette_wheel = [sum(transition_probabilities[:(j+1)]) for j in range((n+1)**2)] 

        #Determine proposal state
        monte_carlo = r.uniform(0,1)
        brk = False
        for k in range(n+1):
            if brk:
                break
            for l in range(n+1):
                index = k*(n+1) + l
                if monte_carlo < roulette_wheel[index]:
                    proposal = [k,l]
                    brk = True
                    break

        ##calculate metropolis weight
        beta_c = beta_list[copy]
        beta_cplus1 = beta_list[copy+1]

        e_energyf = eigensystem_list[copy][0][s[copy][proposal[0]]]
        e_energyfplus1 = eigensystem_list[copy+1][0][s[copy+1][proposal[1]]]      
        
        met_weight = np.exp(-beta_c*e_energyf - beta_cplus1*e_energyfplus1 + beta_c*e_energyi + beta_c*e_energyiplus1)
        
        
        #accept/reject step
        monte_carlo = r.uniform(0,1)
        if monte_carlo < met_weight:
            state[copy] = proposal[0]
            state[copy+1] = proposal[1]
    
    print(state)
    overlap0 = eigensystem_list[0][1][:,s[0][state[0]]]@c_ground
    overlap0 *= np.conj(overlap0)

    overlapl = eigensystem_list[copies-1][1][:,s[copies-1][state[copies-1]]]@c_ground
    overlapl *= np.conj(overlapl)

    gmax+=overlap0
    gmin+=overlapl


print(gmax/steps)
print(gmin/steps)





                    









       

        

        







